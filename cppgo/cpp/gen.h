#include <string>
#include <vector>
#include <map>
#include <functional>
#include <fstream>
#include <sstream>
#include <cctype>
#include <stdexcept>
#include <algorithm>
#include <filesystem>

using namespace std;
using namespace filesystem;

struct Buffer {
    ostringstream content;

    void write(const string &s) { content << s; }

    void writeLine(const string &s) { content << s << "\n"; }

    void newLine() { content << "\n"; }

    string str() const { return content.str(); }

    void reset() {
        content.str("");
        content.clear();
    }
};

struct GeneratedFile {
    Buffer                         buffer;
    string                         packageName = "main";
    string                         filePath;
    int                            enumBase = 0;
    string                         enumType = "int";
    vector<uint32_t>               values;
    function<string(bool, string)> callback;
    bool                           keepOrigName = false;

    GeneratedFile *SetKeepOrigName(bool keep) {
        keepOrigName = keep;
        return this;
    }

    void SetCallback(function<string(bool, string)> cb) { callback = cb; }

    GeneratedFile *SetValues(const vector<uint32_t> &vals) {
        values = vals;
        return this;
    }

    GeneratedFile *SetFilePath(const string &path) {
        filePath = path;
        return this;
    }

    GeneratedFile *SetPackageName(const string &pkg) {
        packageName = pkg;
        return this;
    }

    GeneratedFile *SetEnumBase(int base) {
        enumBase = base;
        return this;
    }

    GeneratedFile *SetEnumType(const string &type) {
        enumType = type;
        return this;
    }

    string Format() { return buffer.str(); }

    void PC(bool is64Bit, const string &v) {
        if (callback) {
            Write(callback(is64Bit, v));
        } else {
            Write(v);
        }
    }

    void PKeepSpace(const string &s) { WriteLine(s); }

    void P(const string &s) { WriteLine(Trim(s)); }

    void EnumTypes(const string &name, const map<string, string> &typeTooltipMap) {
        try {
            vector<string> names;
            vector<string> tooltips;

            for (const auto &[key, value]: typeTooltipMap) {
                names.push_back(keepOrigName ? Trim(key) : ToCamelUpper(Trim(key)));
                tooltips.push_back(Trim(value));
            }

            string typeNameUpper = ToCamelUpper(name);
            if (packageName.empty()) { packageName = GetPackageName(); }

            WriteLine("package " + packageName);
            WriteLine("");

            WriteLine("import (");
            WriteLine("    \"github.com/ddkwork/golibrary/stream\"");
            WriteLine("    \"strings\"");
            WriteLine(")");
            WriteLine("");

            WriteLine("// Code generated by EnumTypesGen - DO NOT EDIT.");
            WriteLine("");

            auto fnInvalidType = [this]() { WriteLine("    panic(\"InvalidType\")"); };

            string method = typeNameUpper + "Type";

            WriteLine("type " + method + " " + enumType);
            WriteLine("");
            WriteLine("const (");

            for (size_t i = 0; i < names.size(); i++) {
                string valueExpr;
                if (!values.empty()) {
                    if (values.size() != names.size()) { throw runtime_error("values length not equal to names length"); }
                    valueExpr = to_string(values[i]);
                } else {
                    if (i == 0) {
                        valueExpr = "iota";
                        if (enumBase != 0) { valueExpr += " + " + to_string(enumBase); }
                    } else {
                        valueExpr = "";
                    }
                }

                WriteLine("    " + names[i] + "Type" + (valueExpr.empty() ? "" : " = " + valueExpr));
            }

            WriteLine(")");
            WriteLine("");

            string minTypeName = names[0] + "Type";
            string maxTypeName = names.back() + "Type";

            WriteLine("func (t " + method + ") Valid() bool {");
            WriteLine("    return t >= " + minTypeName + " && t <= " + maxTypeName);
            WriteLine("}");
            WriteLine("");

            WriteLine("func " + method + "By[T stream.Integer](v T) " + method + " {");
            WriteLine("    return " + method + "(v)");
            WriteLine("}");
            WriteLine("");

            WriteLine("func (t " + method + ") AssertBy(name string) " + method + " {");
            WriteLine("    name = strings.TrimSuffix(name, \"Type\")");
            WriteLine("    for _, n := range t.EnumTypes() {");
            WriteLine("        if strings.EqualFold(name, n.String()) {");
            WriteLine("            return n");
            WriteLine("        }");
            WriteLine("    }");
            fnInvalidType();
            WriteLine("}");
            WriteLine("");

            WriteLine("func (t " + method + ") String() string {");
            WriteLine("    switch t {");
            for (const auto &name: names) {
                WriteLine("    case " + name + "Type:");
                WriteLine("        return \"" + name + "\"");
            }
            WriteLine("    default:");
            fnInvalidType();
            WriteLine("    }");
            WriteLine("}");
            WriteLine("");

            if (!tooltips.empty()) {
                WriteLine("func (t " + method + ") Tooltip() string {");
                WriteLine("    switch t {");
                for (size_t i = 0; i < names.size(); i++) {
                    WriteLine("    case " + names[i] + "Type:");
                    WriteLine("        return \"" + tooltips[i] + "\"");
                }
                WriteLine("    default:");
                fnInvalidType();
                WriteLine("    }");
                WriteLine("}");
                WriteLine("");
            }

            WriteLine("func (t " + method + ") Names() []string {");
            WriteLine("    return []string{");
            for (const auto &name: names) { WriteLine("        \"" + name + "\","); }
            WriteLine("    }");
            WriteLine("}");
            WriteLine("");

            WriteLine("func (t " + method + ") EnumTypes() []" + method + " {");
            WriteLine("    return []" + method + "{");
            for (const auto &name: names) { WriteLine("        " + name + "Type,"); }
            WriteLine("    }");
            WriteLine("}");
            WriteLine("");

            WriteLine("func (t " + method + ") SvgFileName() string {");
            WriteLine("    return t.String() + \".svg\"");
            WriteLine("}");
            WriteLine("");

            WriteGoFile(path(filePath) / (name + "_types_gen.go"));
        } catch (const exception &e) { cerr << "生成枚举类型时出错: " << e.what() << endl; }
    }

    void ReadTemplates(const string &path, const string &pkg) {
        try {
            string cleanPkg = pkg;
            if (cleanPkg.size() >= 5 && cleanPkg.substr(cleanPkg.size() - 5) == "_test") { cleanPkg = cleanPkg.substr(0, cleanPkg.size() - 5); }

            WriteLine("package " + cleanPkg + "_test");
            NewLine();
            WriteLine("import (");
            WriteLine("    \"github.com/ddkwork/golibrary/stream\"");
            WriteLine(")");
            NewLine();

            WriteLine("func generateIR(path string, callBack func(b *stream.Buffer)) {");
            WriteLine("    g := stream.NewGeneratedFile()");

            ifstream inFile(path);
            if (!inFile) throw runtime_error("无法打开模板文件");

            string line;
            while (getline(inFile, line)) {
                bool needNewLine = line.empty();
                if (line.find("package") == 0) {
                    line = "g.P(\"package " + GetPackageName() + "\")";
                } else {
                    replace(line.begin(), line.end(), '\t', ' ');
                    line = "g.P(\"" + line + "\")";
                }

                WriteLine(line);
                if (needNewLine) { NewLine(); }
            }

            NewLine();
            WriteLine("    callBack(g.Buffer)");
            WriteLine("    stream.WriteGoFile(path, g.Buffer)");
            WriteLine("}");

            cout << buffer.str() << endl;
        } catch (const exception &e) { cerr << "读取模板时出错: " << e.what() << endl; }
    }

private:
    string Trim(const string &str) {
        auto start = str.find_first_not_of(" \t\r\n");
        auto end = str.find_last_not_of(" \t\r\n");
        return (start == string::npos || end == string::npos) ? "" : str.substr(start, end - start + 1);
    }

    string ToCamelUpper(const string &s) {
        string result;
        bool   makeUpper = true;

        for (char c: s) {
            if (c == '_' || c == ' ') {
                makeUpper = true;
            } else if (makeUpper) {
                result += toupper(c);
                makeUpper = false;
            } else {
                result += c;
            }
        }

        return result;
    }

    string GetPackageName() { return "main"; }

    void Write(const string &s) { buffer.write(s); }

    void WriteLine(const string &s) { buffer.writeLine(s); }

    void NewLine() { buffer.newLine(); }

    void WriteGoFile(const path &filePath) {
        create_directories(filePath.parent_path());
        ofstream outFile(filePath);
        if (!outFile) { throw runtime_error("无法打开输出文件: " + filePath.string()); }
        outFile << buffer.str();
        buffer.reset();
    }
};

int main() {
    GeneratedFile gen;

    gen.SetFilePath("output").SetPackageName("permissions").SetEnumType("uint8");

    map<string, string> permissions = {{"read", "Read permission"}, {"write", "Write permission"}, {"execute", "Execute permission"}};

    gen.EnumTypes("Permission", permissions);

    vector<uint32_t> customValues = {1, 2, 4};
    gen.SetValues(customValues).EnumTypes("AccessLevel", {{"user", "Standard user access"}, {"admin", "Administrator access"}, {"root", "Full system access"}});

    gen.SetKeepOrigName(true).EnumTypes("LogLevel", {{"debug", "Debug level"}, {"info", "Info level"}, {"warn", "Warning level"}, {"error", "Error level"}});

    gen.ReadTemplates("templates/action.yml", "github_actions");

    return 0;
}

package bindgen

import (
	"bytes"
	_ "embed"
	"fmt"
	"github.com/ddkwork/golibrary/std/clang"
	"github.com/ddkwork/golibrary/std/mylog"
	"github.com/tidwall/gjson"
	"os"
	"regexp"
	"strconv"
	"testing"
	"text/template"

	"github.com/ddkwork/golibrary/std/assert"
)

func TestBug(t *testing.T) {
	jsonBody := `
{
  "id" : "0x26035761dc8",
  "kind" : "FunctionDecl",
  "loc" : {
    "offset" : 860,
    "line" : 47,
    "col" : 30,
    "tokLen" : 25
  },
  "range" : {
    "begin" : {
      "spellingLoc" : {
        "offset" : 608,
        "line" : 32,
        "col" : 23,
        "tokLen" : 10
      },
      "expansionLoc" : {
        "offset" : 831,
        "line" : 47,
        "col" : 1,
        "tokLen" : 13
      }
    },
    "end" : {
      "offset" : 925,
      "col" : 95,
      "tokLen" : 1
    }
  },
  "name" : "BridgeLoadLibraryCheckedW",
  "mangledName" : "BridgeLoadLibraryCheckedW",
  "type" : {
    "desugaredQualType" : "HMODULE (const wchar_t *, bool)",
    "qualType" : "HMODULE (const wchar_t *, bool) __attribute__((stdcall))"
  },
  "inner" : [ {
    "id" : "0x26035761ba8",
    "kind" : "ParmVarDecl",
    "loc" : {
      "offset" : 901,
      "col" : 71,
      "tokLen" : 5
    },
    "range" : {
      "begin" : {
        "offset" : 886,
        "col" : 56,
        "tokLen" : 5
      },
      "end" : {
        "offset" : 901,
        "col" : 71,
        "tokLen" : 5
      }
    },
    "name" : "szDll",
    "type" : {
      "qualType" : "const wchar_t *"
    }
  }, {
    "id" : "0x26035761c28",
    "kind" : "ParmVarDecl",
    "loc" : {
      "offset" : 913,
      "col" : 83,
      "tokLen" : 12
    },
    "range" : {
      "begin" : {
        "offset" : 908,
        "col" : 78,
        "tokLen" : 4
      },
      "end" : {
        "offset" : 913,
        "col" : 83,
        "tokLen" : 12
      }
    },
    "name" : "allowFailure",
    "type" : {
      "qualType" : "bool"
    }
  }, {
    "id" : "0x26035761e80",
    "kind" : "DLLImportAttr",
    "range" : {
      "begin" : {
        "spellingLoc" : {
          "offset" : 619,
          "line" : 32,
          "col" : 34,
          "tokLen" : 9
        },
        "expansionLoc" : {
          "offset" : 831,
          "line" : 47,
          "col" : 1,
          "tokLen" : 13
        }
      },
      "end" : {
        "spellingLoc" : {
          "offset" : 619,
          "line" : 32,
          "col" : 34,
          "tokLen" : 9
        },
        "expansionLoc" : {
          "offset" : 831,
          "line" : 47,
          "col" : 1,
          "tokLen" : 13
        }
      }
    }
  } ]
}
`
	root := gjson.Parse(jsonBody)
	functionInfo := parseFunction(root, "")
	mylog.Struct(functionInfo.Params)
}

func TestWalk(t *testing.T) {
	clang.Walk("D:\\workspace\\workspace\\bindgen\\cppgo\\HyperDbg")
}

func Test_handleQualType(t *testing.T) {
	// assert.Equal(t, "[64]int8", handleQualType("char[64]"))
	assert.Equal(t, "[8]uint64", handleQualType("unsigned long long[8]"))
}

type FieldLayout struct {
	Name     string
	BitWidth int
	Offset   int
}

// 2. 模拟Clang输出的内存布局（实际应从文件读取）
const clangOutput = `
*** Dumping IRgen Record Layout
0 | struct _CR3_TYPE
0 |   union
0 |     UINT64 Flags
0 |     struct Fields
0 |       UINT64 Pcid : 12 (Offset:0)
12 |       UINT64 PageFrameNumber : 36 (Offset:12)
48 |       UINT64 Reserved1 : 12 (Offset:48)
60 |       UINT64 Reserved_2 : 3 (Offset:60)
63 |       UINT64 PcidInvalidate : 1 (Offset:63)
[Size:64, Align:64]
`

// 3. 解析Clang布局输出的核心逻辑
func parseLayout(output string) []FieldLayout {
	// 正则表达式匹配模式
	pattern := `(\w+)\s*:\s*(\d+).*?Offset:(\d+)`
	re := regexp.MustCompile(pattern)
	matches := re.FindAllStringSubmatch(output, -1)

	var fields []FieldLayout
	for _, m := range matches {
		width, _ := strconv.Atoi(m[2])
		offset, _ := strconv.Atoi(m[3])
		fields = append(fields, FieldLayout{
			Name:     m[1],
			BitWidth: width,
			Offset:   offset,
		})
	}
	return fields
}

// 4. Go代码生成模板
const codeTemplate = `// Code generated by clang2go; DO NOT EDIT.
package main

type {{.StructName}} struct {
	value uint{{.TotalBits}}
}

const (
{{range .Fields}}	{{.Name}}Mask = 0x{{printf "%X" (mask .BitWidth .Offset)}}
{{end}})

{{range .Fields}}
func (s *{{$.StructName}}) Get{{.Name}}() uint{{$.TotalBits}} {
	return (s.value & {{.Name}}Mask) >> {{.Offset}}
}

func (s *{{$.StructName}}) Set{{.Name}}(v uint{{$.TotalBits}}) {
	s.value = (s.value &^ {{.Name}}Mask) | ((v << {{.Offset}}) & {{.Name}}Mask)
}
{{end}}`

// 5. 生成最终代码
func generateCode(layout []FieldLayout) string {
	tmpl := template.Must(template.New("code").Funcs(template.FuncMap{
		"mask": func(width, offset int) uint64 {
			return (1<<width - 1) << offset
		},
	}).Parse(codeTemplate))

	data := map[string]any{
		"StructName": "CR3_TYPE",
		"TotalBits":  64,
		"Fields":     layout,
	}

	var buf bytes.Buffer
	tmpl.Execute(&buf, data)
	return buf.String()
}

// 6. 主执行流程
func main() {
	// Step 1: 解析Clang输出
	fields := parseLayout(clangOutput)

	// Step 2: 生成Go代码
	code := generateCode(fields)

	// Step 3: 输出到文件
	os.WriteFile("cr3_type.go", []byte(code), 0o644)
	fmt.Println("Generated cr3_type.go")
}

// /////////////////////////////////////////////////

////go:embed cache/_dbgfunctions.h.json
//var productInfo []byte
//
//func TestJsonTree(t *testing.T) {
//	ux.Run("jsonTree", jsontree.Layout(productInfo))
//}

func Test_extractFlags(t *testing.T) {
	got := extractFlags()
	mylog.Struct(got)
}

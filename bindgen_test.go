package bindgen

import (
	"bytes"
	_ "embed"
	"fmt"
	"github.com/ddkwork/golibrary/clang"
	"github.com/ddkwork/golibrary/mylog"
	"os"
	"regexp"
	"strconv"
	"testing"
	"text/template"

	"github.com/ddkwork/golibrary/assert"
)

func TestWalk(t *testing.T) {
	clang.Walk("D:\\workspace\\workspace\\bindgen\\cppgo\\HyperDbg")
}

func Test_handleQualType(t *testing.T) {
	// assert.Equal(t, "[64]int8", handleQualType("char[64]"))
	assert.Equal(t, "[8]uint64", handleQualType("unsigned long long[8]"))
}

type FieldLayout struct {
	Name     string
	BitWidth int
	Offset   int
}

// 2. 模拟Clang输出的内存布局（实际应从文件读取）
const clangOutput = `
*** Dumping IRgen Record Layout
0 | struct _CR3_TYPE
0 |   union
0 |     UINT64 Flags
0 |     struct Fields
0 |       UINT64 Pcid : 12 (Offset:0)
12 |       UINT64 PageFrameNumber : 36 (Offset:12)
48 |       UINT64 Reserved1 : 12 (Offset:48)
60 |       UINT64 Reserved_2 : 3 (Offset:60)
63 |       UINT64 PcidInvalidate : 1 (Offset:63)
[Size:64, Align:64]
`

// 3. 解析Clang布局输出的核心逻辑
func parseLayout(output string) []FieldLayout {
	// 正则表达式匹配模式
	pattern := `(\w+)\s*:\s*(\d+).*?Offset:(\d+)`
	re := regexp.MustCompile(pattern)
	matches := re.FindAllStringSubmatch(output, -1)

	var fields []FieldLayout
	for _, m := range matches {
		width, _ := strconv.Atoi(m[2])
		offset, _ := strconv.Atoi(m[3])
		fields = append(fields, FieldLayout{
			Name:     m[1],
			BitWidth: width,
			Offset:   offset,
		})
	}
	return fields
}

// 4. Go代码生成模板
const codeTemplate = `// Code generated by clang2go; DO NOT EDIT.
package main

type {{.StructName}} struct {
	value uint{{.TotalBits}}
}

const (
{{range .Fields}}	{{.Name}}Mask = 0x{{printf "%X" (mask .BitWidth .Offset)}}
{{end}})

{{range .Fields}}
func (s *{{$.StructName}}) Get{{.Name}}() uint{{$.TotalBits}} {
	return (s.value & {{.Name}}Mask) >> {{.Offset}}
}

func (s *{{$.StructName}}) Set{{.Name}}(v uint{{$.TotalBits}}) {
	s.value = (s.value &^ {{.Name}}Mask) | ((v << {{.Offset}}) & {{.Name}}Mask)
}
{{end}}`

// 5. 生成最终代码
func generateCode(layout []FieldLayout) string {
	tmpl := template.Must(template.New("code").Funcs(template.FuncMap{
		"mask": func(width, offset int) uint64 {
			return (1<<width - 1) << offset
		},
	}).Parse(codeTemplate))

	data := map[string]any{
		"StructName": "CR3_TYPE",
		"TotalBits":  64,
		"Fields":     layout,
	}

	var buf bytes.Buffer
	tmpl.Execute(&buf, data)
	return buf.String()
}

// 6. 主执行流程
func main() {
	// Step 1: 解析Clang输出
	fields := parseLayout(clangOutput)

	// Step 2: 生成Go代码
	code := generateCode(fields)

	// Step 3: 输出到文件
	os.WriteFile("cr3_type.go", []byte(code), 0o644)
	fmt.Println("Generated cr3_type.go")
}

// /////////////////////////////////////////////////

////go:embed cache/_dbgfunctions.h.json
//var productInfo []byte
//
//func TestJsonTree(t *testing.T) {
//	ux.Run("jsonTree", jsontree.Layout(productInfo))
//}

func Test_extractFlags(t *testing.T) {
	got := extractFlags()
	mylog.Struct(got)
}
